---
layout: post
title: "Java-JVM内存垃圾回收机制gc详解"
categories: [Java]
description: ""
keywords: Java
---

此文首发于我的Jekyll博客：[zhang0peter的个人博客](https://zhang0peter.com)         

{% raw %}
***          
{% endraw %}
## GC的优缺点

Java对比C++最大的优势是内存自动回收，无需手动删除对象，因此需要垃圾回收器(GC)来确认哪些对象是无用的对象，从而可以回收这些对象所占用的内存空间。

但GC(垃圾回收)也不是完美的，缺点就是如果会在程序运行时产生暂停；一般来说垃圾回收算法越好，暂停时间越短暂。

而JVM的垃圾回收器在这么多年来经历了多次变革，比如说： G1 成为 Java 9 开始的默认垃圾回收器，Oracle 发布了 ZGC（受 Azul 无停顿回收器 C4 的启发），然后是 Red Hat 开发了 Shenandoah(会加入 jdk 13)。

如果你的应用程序是交互式的（比如一组 API 或一个网站），那么 GC 停顿所造成的影响就会更加明显了。GC 停顿会拖慢应用程序，在外界看来，它就像冻住了一样。在 GC 停顿期间发给服务器的请求会更晚收到响应，根据停顿时间的不同（传统的 GC 停顿有可能达到几十秒），客户端有可能会出现超时。

GC的过程分为标记垃圾对象和垃圾回收2步。

## 对象标记算法
在偌大的内存上存活着无数对象， GC 之前需要准确将这些对象标记出来，分为存活对象与垃圾对象。这个过程一旦少标记，那就只能等待下次 GC 标记，再回收，这样将会影响 GC 效率。

### 引用计数法

引用计数法通过在对象头分配一个字段，用来存储该对象引用计数。一旦该对象被其他对象引用，计数加 1。如果这个引用失效，计数减 1。当引用计数值为 0 时，代表这个对象已不再被引用，可以被回收。

引用计数法只需要判断计数值，所以实现比较简单，这个过程也比较高效。但是存在一个很严重的问题，无法解决对象循环引用问题。

### 可达性分析法

首先需要按照规则查找当前活跃的引用，将其称为 GC Roots 。接着将 GC Roots 作为根节点出发，遍历对象引用关系图，将可以遍历（可达）的对象标记为存活，其余对象当做无用对象。

这个算法的原理也很简单，就是维护一系列的『GC ROOT』的对象作为我们的根，从这些根搜索，走过的路径官方话叫做引用链（Reference Chain），当一个对象到根节点没有任何引用，就意味着这个对象是不可用的，也就是我们俗称的垃圾

注意这里是是 引用 ，而不是对象。

可以被当做 GC Roots 活跃引用包括但不限于以下引用：

方法中局部变量
静态变量，常量
JNI handles

## 回收算法
目前主流 GC 算法主要分为三种：

标记-清除算法
复制算法
标记-整理算法

### 标记-清除算法

这是一个最为基础也是最容易实现的算法，主要实现步骤分为两步：标记，清除。

标记：通过上述 GC Roots 标记出可达对象。
清除：清理 未标记对象 。

可以看到经过这个算法回收之后，虽然堆空间被清理出来，但是也产生很多 空间碎片 。这就会导致一个新对象根据堆剩余容量计算，看起来是可以分配，但是实际分配过程，由于没有连续内存，导致虚拟机感知到内存不足，又不得不提前再次触发 GC 。

另外这个算法还有一个不足：标记与清除效率比较低。这就竟会导致 GC 占用时间过长，影响正常程序使用。

### 复制算法
为了解决上述效率问题，诞生复制算法。这个算法将可用内存分为两块，每次只使用其中一块，当这一块内存使用完毕，触发 GC ，将会把存活的对象依次复制到另外一块上，然后再把已使用过的内存一次性清理。

这个算法每次只需要操作一半内存， GC 回收之后也不存在任何空间碎片，新对象内存分配时只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。但是这个算法闲置一半内存空间，空间利用效率不高。

PS：复制算法以空间换时间，两者不可兼得

### 标记-整理算法

标记-整理算法可以说是标记-清除算法的改进版，改进了清除导致的空间碎片问题。这个算法分为两步

虽然标记-整理算法解决了标记-清除算法空间碎片问题，也完整利用整个内存空间，但是这个算法问题效率并不高。相较于标记-清除算法，标记-整理算法多增加整理这一步，所以该算法效率还低于标记-清除算法。

### 分代收集算法
从上面三种 GC 算法可以看到，并没有一种空间与时间效率都是比较完美的算法，所以只能做的是综合利用各种算法特点将其作用到不用的内存区域。

目前JVM虚拟机根据对象存活周期不同划分内存区域，一般分为新生代，老年代。新对象一般情况都会优先分配在新生代，新生代对象若存活时间大于一定阈值之后，将会移到至老年代。新生代的对象都是短命鬼，老年代的对象都是长寿先生。

新生代每次 GC 之后都可以回收大批量对象，所以比较适合复制算法，只需要付出少量复制存活对象的成本。这里内存划分并没有按照 1:1 划分，默认将会按照 8:1:1 划分成 Eden 与两块 Survivor 空间。每次使用 Eden 与一块 Survivor 空间，这样我们只是闲置 10% 内存空间。不过我们每次回收并不能保证存活对象小于 10%,在这种情况下就需要依靠老年代的内存分配担保。当 Survivor 空间并不能保存剩余存活对象，就将这些对象通过分配担保进制移动至老年代。

老年代中对象存活率将会特别高，且没有额外空间进行分配担保，所以并不适合复制算法，所以需要使用标记-清除或标记-整理算法。





## 常见的GC

`HotSpot JVM`是`Oracle Java`使用的JVM，也就是内存管理等都由`HotSpot`负责，而垃圾回收算法的选择也是JVM中的一部分，因此你可以指定JVM的GC算法。      
比如说在 java 8中的命令行参数可以指定如下参数：
```sh
-XX:+UseConcMarkSweepGC # 允许将CMS垃圾收集器用于旧版本。当吞吐量（-XX:+UseParallelGC）垃圾收集器无法满足应用程序延迟要求时，Oracle建议您使用CMS垃圾收集器。G1垃圾收集器（-XX:+UseG1GC）是另一种选择。
-XX:+UseG1GC #启用垃圾优先（G1）垃圾收集器的使用。它是一种服务器样式的垃圾收集器，适用于具有大量RAM的多处理器计算机。它极有可能满足GC暂停时间目标，同时保持良好的吞吐量。建议将G1收集器用于需要大堆（大小约为6 GB或更大）且GC延迟要求有限（稳定且可预测的暂停时间低于0.5秒）的应用程序。默认情况下，此选项是禁用的，并且将根据计算机的配置和JVM的类型自动选择收集器。
-XX:+UseParallelGC #启用并行清除垃圾收集器（也称为吞吐量收集器）的使用，以利用多个处理器来提高应用程序的性能。
-XX:+UseParNewGC #允许在新生代中使用并行线程进行收集。默认情况下，此选项是禁用的。设置-XX:+UseConcMarkSweepGC选项后，它将自动启用。使用-XX:+UseParNewGC不带选项-XX:+UseConcMarkSweepGC的选择是在JDK 8弃用。
-XX:+UseSerialGC #启用串行垃圾收集器的使用。对于不需要垃圾回收具有任何特殊功能的小型和简单应用程序，这通常是最佳选择。默认情况下，此选项是禁用的，并且将根据计算机的配置和JVM的类型自动选择收集器。
```

从 Java 9开始，默认的垃圾收集器(garbage collector (GC) )从`Parallel GC`换成`G1`，见`JEP 248`，原因是`对大部分普通用户来说，限制GC暂停时间比最大化吞吐量更为重要。`

在 JDK 9之后，CMS collector 被彻底抛弃。



经典 GC（也叫作 STW，Stop-The-World）会在没有可用内存时暂停应用程序线程，回收垃圾，并压缩存活的对象，然后让应用程序继续执行。这种停顿有可能长达几十秒，而且会随着堆的增大而延长。

很多现代 GC（例如 G1）有分代的概念，它们根据对象在垃圾回收过程中存活下来的次数对这些对象进行分代，并针对每一个分代的对象使用不同的回收策略。









参考：
- [oracle java docs](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABFAFAE)      
- [java Command-Line Options](https://docs.oracle.com/en/java/javase/11/jrockit-hotspot/garbage-collectors.html#GUID-06A715F3-68D2-412E-B32A-6D6D5540392B)      
- [jvm - OpenJDK vs Java HotspotVM - Stack Overflow](https://stackoverflow.com/questions/44335605/openjdk-vs-java-hotspotvm)      
- [Frequently Asked Questions About the Java HotSpot VM](https://www.oracle.com/technetwork/java/hotspotfaq-138619.html)      
- [最新JVM垃圾回收器Shenandoah GC的实践案例 - InfoQ](https://www.infoq.cn/article/L4LU1J0VxXtA6ASeGYbV)      
- [直击面试，聊聊 GC 机制 - 楼下小黑哥 - 博客园](https://www.cnblogs.com/goodAndyxublog/p/12051482.html)      
- []()      
- []()      
- []()      
- []()      
- []()      
- []()      
- []()      
- []()      
- []()      
