---
layout: post
title: "LeetCode 22. Generate Parentheses--Python 解法--广度优先、深度优先解法"
categories: [LeetCode]
description: "LeetCode 22. Generate Parentheses--Python 解法--广度优先、深度优先解法"
keywords: LeetCode, Python
---

此文首发于我的个人博客：[zhang0peter的个人博客](https://zhang0peter.com)         

{% raw %}
***          
{% endraw %}


LeetCode题解文章分类：[LeetCode题解文章集合](https://zhang0peter.com/categories/#LeetCode)               
LeetCode 所有题目总结：[LeetCode 所有题目总结](https://zhang0peter.blog.csdn.net/article/details/100055202)                                  

{% raw %}
***          
{% endraw %}

题目地址：[Generate Parentheses - LeetCode](https://leetcode.com/problems/generate-parentheses/)

{% raw %}
***          
{% endraw %}

Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```


{% raw %}
***          
{% endraw %}

这道题目看起来不难，只要把所有的可能性都输出即可。

可以深度优先，或者广度优先解决。

广度优先的Python解法如下，先输出 `()()()...` 

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        def helper(s='', left=0, n=0):
            if n == 0:
                self.res.append(s+')'*left)
                return
            if left > 0:
                helper(s+')', left-1, n)
            helper(s+'(', left+1, n-1)
        self.res = []
        helper('', 0, n)
        return self.res
```

深度优先解法如下，先 `((()))` 

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        def helper(s='', left=0, n=0):
            if n == 0:
                self.res.append(s+')'*left)
                return
            helper(s+'(', left+1, n-1)
            if left > 0:
                helper(s+')', left-1, n)
        self.res = []
        helper('', 0, n)
        return self.res
```





