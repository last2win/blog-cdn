---
layout: post
title: "LeetCode 122. Best Time to Buy and Sell Stock II--贪心--Java,C++,Python解法"
categories: [LeetCode]
description: "LeetCode 122. Best Time to Buy and Sell Stock II--贪心--Java,C++,Python解法"
keywords: LeetCode
---

此文首发于我的个人博客：[zhang0peter的个人博客](https://zhang0peter.com)         

{% raw %}
***          
{% endraw %}

LeetCode题解文章分类：[LeetCode题解文章集合](https://zhang0peter.com/categories/#LeetCode)               
LeetCode 所有题目总结：[LeetCode 所有题目总结](https://zhang0peter.blog.csdn.net/article/details/100055202)   
{% raw %}
***          
{% endraw %}
题目地址：[Best Time to Buy and Sell Stock II - LeetCode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)
{% raw %}
***          
{% endraw %}
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:
```
Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
```
Example 2:
```
Input: [1,2,3,4,5]
Output: 4

Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
```
Example 3:
```
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```
{% raw %}
***          
{% endraw %}
这道题目可以买卖多次，用贪心就可以解出来了。
Python解法如下：
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        hold=0
        profit=0
        now=-1
        for i in prices:
            if now==-1:
                now=i
            elif i<now:
                now=i
            elif i>now:
                profit+=i-now
                now=i
        return profit
```
Java解法如下：
```java
class Solution {
    public int maxProfit(int[] prices) {
        int i = 0;
        if (prices.length==0){
            return 0;
        }
        int valley = prices[0];
        int peak = prices[0];
        int maxprofit = 0;
        while (i < prices.length - 1) {
            while (i < prices.length - 1 && prices[i] >= prices[i + 1])
                i++;
            valley = prices[i];
            while (i < prices.length - 1 && prices[i] <= prices[i + 1])
                i++;
            peak = prices[i];
            maxprofit += peak - valley;
        }
        return maxprofit;
    }
}
```
C++解法如下：
```c
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len=prices.size();
        int profit=0;
        if(len==0||len==1)
        return 0;
    
    for(int i=0;i<len-1;i++)
    {
        if(prices[i]<prices[i+1])
            profit+=prices[i+1]-prices[i];
    }
    
    return profit;
    }
};
```

